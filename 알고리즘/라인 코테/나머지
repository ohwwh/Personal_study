문제 설명
어떤 회사에서 담당 업무에 따라 사원 몇 명을 재택근무로 전환하려 합니다. 업무는 재택 가능한 업무, 출근해야 할 업무 두 가지 종류가 있습니다. 어떤 사원의 업무가 재택 가능한 업무로만 이루어져 있다면, 그 사원은 재택근무 대상자입니다.

회사에는 1번부터 num_employees번까지 각각 다른 사원 번호를 가진 num_employees명의 사원들이 있습니다. 회사의 사원들은 num_teams개의 팀으로 나뉘어 있으며, 사원마다 소속된 팀 번호가 있습니다. 팀마다 최소 한 명은 출근해야 합니다. 만약 어떤 팀에서 팀원 모두가 재택근무 대상자일 때, 사원 번호가 가장 빠른 사람이 출근하기로 했습니다. 이에 해당하지 않는 재택근무 대상자들은 재택근무를 하게 됩니다. 당신은 재택근무를 하게 될 사원의 번호를 구하려 합니다.

다음과 같은 업무와 사원들의 정보가 있을 때의 예시를 들어보겠습니다.

재택 가능한 업무: development marketing hometask

출근해야 할 업무: recruitment education officetask

사원 번호	소속 팀 번호	담당 업무
1	1	development hometask
2	1	recruitment marketing
3	2	hometask
4	2	development marketing hometask
5	3	marketing
6	3	officetask
7	3	development
재택 가능한 업무만 하는 사원은 (1,3,4,5,7) 5명입니다.
1,3번 팀은 출근하는 팀원이 있지만 2번 팀은 모두 재택근무 대상자입니다. 그러므로, 2번 팀에서 사원 번호가 가장 빠른 3번 사원은 출근해야 합니다.
재택근무를 하게 될 사원은 (1,4,5,7) 4명입니다.
팀의 개수를 나타내는 정수 num_teams, 재택 가능한 업무들을 나타내는 문자열 배열 remote_tasks, 출근해야 할 업무들을 나타내는 문자열 배열 office_tasks, 사원들의 정보를 1번 사원부터 순서대로 나타내는 문자열 배열 employees가 매개변수로 주어집니다. 재택근무를 하게 될 사원들의 번호를 정수 배열에 오름차순으로 담아 return 하도록 solution 함수를 완성해 주세요. 최소 한 명 이상 재택근무를 하게 될 사원이 존재하는 경우만 주어집니다.

제한사항
1 ≤ num_teams ≤ 10
1 ≤ remote_tasks의 길이 ≤ 100
3 ≤ remote_tasks의 원소의 길이 ≤ 20
1 ≤ office_tasks의 길이 ≤ 100
3 ≤ office_tasks의 원소의 길이 ≤ 20
remote_tasks와 office_tasks는 중복되는 원소가 나타나지 않으며, 서로 중복되는 원소가 없습니다.
remote_tasks와 office_tasks의 원소는 알파벳 소문자로만 이루어져 있습니다.
num_teams < employees의 길이 = num_employees ≤ 100
employees의 원소는 "team_number task_list" 형태의 문자열입니다. team_number는 해당 사원의 팀 번호를 나타내고, task_list는 해당 사원의 담당 업무를 나타내는 문자열입니다.
1 ≤ team_number ≤ num_teams
1~num_teams의 각각의 팀에는 적어도 한 명 이상 소속된 팀원이 있습니다.
모든 사원은 최소 1개 ~ 최대 40개의 업무를 담당합니다.
task_list 는 담당 업무를 하나의 공백으로 구분해 담고 있습니다. 반드시 remote_tasks, office_tasks 둘 중 하나에 나타난 업무만 담겨있습니다.
task_list 에는 중복된 원소가 나타나지 않습니다.
입출력 예
num_teams	remote_tasks	office_tasks	employees	result
3	["development","marketing","hometask"]	["recruitment","education","officetask"]	["1 development hometask","1 recruitment marketing","2 hometask","2 development marketing hometask","3 marketing","3 officetask","3 development"]	[1,4,5,7]
2	["design"]	["building","supervise"]	["2 design","1 supervise building design","1 design","2 design"]	[3,4]
입출력 예 설명
입출력 예 #1

문제 예시와 동일합니다.
입출력 예 #2

재택 가능한 업무: design

출근해야 할 업무: building supervise

사원 번호	소속 팀 번호	담당 업무
1	2	design
2	1	supervise building design
3	1	design
4	2	design
재택 가능한 업무만 하는 사원은 (1,3,4) 3명입니다.
1번 팀은 출근하는 팀원이 있지만 2번 팀은 모두 재택근무 대상자입니다. 그러므로, 2번 팀에서 사원 번호가 가장 빠른 1번 사원은 출근해야 합니다.
재택근무를 하게 될 사원은 (3,4) 2명입니다.





문제 설명
표 편집 프로그램을 통해서 셀의 너비를 원하는 대로 조절하려고 합니다.
아래 그림의 위쪽 셀들은 초기 상태의 셀들이며, 초기 상태 셀들의 너비를 화살표 아래쪽 셀들의 너비처럼 조절하려고 합니다.

lenexcel (8).jpg

셀의 너비는 셀끼리 인접한 경계선을 움직여서 조절합니다. 한쪽 셀의 너비를 줄이면 그만큼 인접한 셀의 너비가 늘어납니다.
모든 초기 셀의 너비는 1이 될 때까지 줄일 수 있지만, 셀을 지우거나 생성할 수는 없습니다.

위 그림의 셀은 아래 그림처럼 총 3번의 조절로 원하는 너비로 바꿀 수 있습니다.

lenexcel (7).jpg

초기 셀들의 너비를 담고 있는 정수 배열 arr과 원하는 셀들의 너비를 담고 있는 정수 배열 brr이 매개변수로 주어집니다. 초기 셀들의 너비를 원하는 너비로 바꾸기 위한 최소 조절 횟수를 return 하도록 solution 함수를 완성해주세요.

제한사항
2 ≤ arr 길이 = brr 길이 ≤ 300,000
1 ≤ arr의 원소, brr의 원소 ≤ 250
arr의 원소의 합 = brr의 원소의 합 ≤ 10,000,000
입출력 예
arr	brr	result
[3, 7, 2, 4]	[4, 5, 5, 2]	3
[6, 2, 2, 6]	[4, 4, 4, 4]	2
입출력 예 설명
입출력 예 #1

문제 예시와 같습니다.

입출력 예 #2

lenexcel (9).jpg





문제 설명
당신은 새로 만들어진 두 개의 팀 중 한 팀을 이끄는 리더입니다. 당신은 상대 팀 리더와 경쟁을 통해 사람들을 팀으로 데려옵니다. 매 라운드마다 각 리더는 사람을 한 명씩 선택할 수 있으며, 항상 상대 팀 리더가 먼저 선택합니다. 대신, 당신에게는 원할 때 쓸 수 있는 우선권 k개가 주어집니다. 우선권을 사용한 라운드는 당신이 상대 리더보다 먼저 선택할 수 있습니다.

당신을 포함하여 리더는 항상 남은 사람들 중 가장 능력치가 높은 사람을 먼저 데려갑니다. 당신은 이 우선권을 이용해 팀원의 능력치 합이 최대한 높은 팀을 만들려고 합니다.

예를 들어 사람들의 능력치를 담은 배열이 [2, 8, 3, 6, 1, 9, 1, 9]이고, 당신에게 우선권이 2개 있는 경우, 다음과 같이 행동할 수 있습니다.

첫 번째 라운드에서는 우선권을 사용하지 않습니다. 상대는 능력치가 9인 사람을 데려가고, 당신은 능력치가 9인 사람을 데려갑니다. 남은 사람들의 능력치는 [2, 8, 3, 6, 1, 1]입니다.
두 번째 라운드에서는 우선권을 사용합니다. 당신은 능력치가 8인 사람을 데려가고, 상대는 능력치가 6인 사람을 데려갑니다. 남은 사람들의 능력치는 [2, 3, 1, 1]입니다.
세 번째 라운드에서도 우선권을 사용합니다. 당신은 능력치가 3인 사람을 데려가고, 상대는 능력치가 2인 사람을 데려갑니다. 남은 사람들의 능력치는 [1, 1]입니다.
네 번째 라운드부터는 우선권을 모두 소진했기 때문에 나중에 선택할 수밖에 없습니다. 당신과 상대는 각각 능력치가 1인 사람을 데려갑니다.
위와 같이 행동할 경우 당신은 능력치 합이 9+8+3+1=21인 팀을 만들 수 있습니다. 다른 방법으로 팀원을 선택할 수도 있지만, 능력치 합이 21보다 큰 팀은 만들 수 없습니다.

만약 사람들의 수가 홀수인 경우, 마지막에 남은 한 사람은 우선권을 사용한 경우에만 당신이 데려갈 수 있습니다. 즉, 진행되는 라운드의 총횟수는 (사람 수 + 1)를 2로 나눈 몫과 같습니다.

사람들의 능력치를 담은 정수 배열 abilities와 우선권의 개수를 나타내는 정수 k가 매개변수로 주어집니다. 우선권을 k번 이하로 사용하여 만들 수 있는 팀의 능력치 합의 최댓값을 return 하도록 solution 함수를 완성해주세요.

제한사항
2 ≤ abilities의 길이 ≤ 300,000
1 ≤ abilities의 원소 ≤ 109
0 ≤ 2 * k ≤ abilities의 길이 + 1
입출력 예
abilities	k	result
[2, 8, 3, 6, 1, 9, 1, 9]	2	21
[7, 6, 8, 9, 10]	1	22
입출력 예 설명
입출력 예 #1

문제 예시와 같습니다.

입출력 예 #2

다음과 같이 행동하면 됩니다.

첫 번째 라운드에서는 우선권을 사용하지 않습니다. 상대 리더는 능력치 10인 사람을, 당신은 능력치 9인 사람을 데려갑니다.
두 번째 라운드에서도 우선권을 사용하지 않습니다. 상대 리더는 능력치 8인 사람을, 당신은 능력치 7인 사람을 데려갑니다.
세 번째 라운드에서 우선권을 사용합니다. 당신은 능력치 6인 사람을 데려갑니다.
그 결과, 당신은 능력치 합이 9+7+6=22인 팀을 만들 수 있습니다. 다른 방법으로 팀원을 선택할 수도 있지만, 능력치 합이 22보다 큰 팀은 만들 수 없습니다. 따라서 22를 return 합니다.




문제 설명
당신은 실버를 사용해 골드를 사고파는 온라인 화폐 거래소를 운영합니다. 화폐 거래소를 이용하는 회원들은 알파벳 대소문자로 이루어진 고유한 아이디를 가지고 있습니다. 회원들은 화폐 거래소에 골드 구매 요청과 골드 판매 요청을 등록할 수 있으며, 완료되지 않은 요청은 pending, 완료된 요청은 done을 상태로 가집니다.

판매할 골드의 양이 sell_amount, 판매 가격이 sell_price인 골드 판매 요청의 등록은 다음과 같은 순서로 처리됩니다.

pending 상태인 구매 요청 중 구매 가격이 sell_price 이상인 구매 요청을 찾습니다. 그러한 구매 요청이 여러 개일 경우 구매 가격이 가장 비싼 구매 요청 중 가장 먼저 등록된 구매 요청을 선택합니다. 구매 가격이 sell_price 이상인 구매 요청을 찾지 못했을 경우, 판매 요청은 pending 상태가 되며 등록을 종료합니다.
찾은 구매 요청의 구매 골드 양이 buy_amount 일 때, 골드 1당 sell_price의 가격으로 min(buy_amount, sell_amount) 만큼의 골드 거래가 이루어집니다. 거래가 이루어진 골드의 양이 amount라면, 판매자의 계좌에서 구매자의 계좌로 amount만큼의 골드가 이동하며, 구매자의 계좌에서 판매자의 계좌로 amount × sell_price만큼의 실버가 이동합니다.
구매 요청의 buy_amount가 min(buy_amount, sell_amount) 만큼 감소합니다. buy_amount가 0이 되었다면 해당 구매 요청은 done 상태가 됩니다.
판매 요청의 sell_amount가 min(buy_amount, sell_amount) 만큼 감소합니다. sell_amount가 0이 되었다면 해당 판매 요청은 done 상태가 되며, 등록을 종료합니다.
sell_amount가 1 이상이라면 1번 순서로 돌아갑니다.
골드 구매 요청 또한 골드 판매 요청과 유사하게 처리됩니다. 구매할 골드의 양이 buy_amount, 구매 가격이 buy_price인 골드 구매 요청의 등록은 다음과 같은 순서로 처리됩니다.

pending 상태인 판매 요청 중 판매 가격이 buy_price 이하인 판매 요청을 찾습니다. 그러한 판매 요청이 여러 개일 경우 판매 가격이 가장 싼 판매 요청 중 가장 먼저 등록된 판매 요청을 선택합니다. 판매 가격이 buy_price 이하인 판매 요청을 찾지 못했을 경우, 구매 요청은 pending 상태가 되며 등록을 종료합니다.
찾은 판매 요청의 판매 골드 양이 sell_amount 일 때, 골드 1당 sell_price의 가격으로 min(buy_amount, sell_amount) 만큼의 골드 거래가 이루어집니다. 거래가 이루어진 골드의 양이 amount라면, 판매자의 계좌에서 구매자의 계좌로 amount만큼의 골드가 이동하며, 구매자의 계좌에서 판매자의 계좌로 amount × sell_price만큼의 실버가 이동합니다.
판매 요청의 sell_amount가 min(buy_amount, sell_amount) 만큼 감소합니다. sell_amount가 0이 되었다면 해당 판매 요청은 done 상태가 됩니다.
구매 요청의 buy_amount가 min(buy_amount, sell_amount) 만큼 감소합니다. buy_amount가 0이 되었다면 해당 구매 요청은 done 상태가 되며, 등록을 종료합니다.
buy_amount가 1 이상이라면 1번 순서로 돌아갑니다.
다음은 골드 구매 요청을 처리하는 예시입니다.

pending 상태인 구매 요청

등록 순서	등록자 아이디	구매 수량	구매 가격
2	Andy	10	10
5	Louis	5	11
pending 상태인 판매 요청

등록 순서	등록자 아이디	판매 수량	판매 가격
1	William	7	20
4	Rohan	4	25
3	Rohan	10	40
현재 거래소에 등록된 pending 상태인 구매/판매 요청들이 위와 같을 때, 아이디가 "Andy"인 회원이 구매 수량 = 20, 구매 가격 = 30 인 구매 요청을 등록한다고 가정합니다. 이때, 구매 요청의 등록은 다음과 같이 처리됩니다.

pending 상태인 판매 요청 중 판매 가격이 가장 싼 요청은 등록순서가 1인 "William"의 판매 요청입니다. "Andy" 와 "William" 사이에 수량 = 7, 가격 = 20인 거래가 이루어지며, "William"의 판매 요청은 done 상태가 됩니다.
pending 상태인 판매 요청 중 그다음으로 판매 가격이 가장 싼 요청은 등록순서가 4인 "Rohan"의 판매 요청입니다. "Andy" 와 "Rohan" 사이에 수량 = 4, 가격 = 25인 거래가 이루어지며, "Rohan"의 판매 요청은 done 상태가 됩니다.
pending 상태인 판매 요청 중 그다음으로 판매 가격이 가장 싼 요청은 등록순서가 3인 "Rohan"의 판매 요청이지만, 구매 가격이 판매 가격보다 작으므로 거래는 이루어지지 않고, "Andy"의 구매 요청은 구매 수량 = 9, 구매 가격 = 30인 pending 상태가 됩니다.
위 처리가 끝난 뒤, 화폐 거래소에 등록된 pending 상태인 골드 구매/판매 요청은 아래 표와 같습니다.

pending 상태인 구매 요청

등록 순서	등록자 아이디	구매 수량	구매 가격
2	Andy	10	10
5	Louis	5	11
6	Andy	9	30
pending 상태인 판매 요청

등록 순서	등록자 아이디	판매 수량	판매 가격
3	Rohan	10	40
또한, 화폐 거래소 회원들의 골드/실버 변화를 계산해보면 아래 표와 같습니다.

회원 아이디	골드 변화	실버 변화
Andy	+11	-240
Louis	0	0
Rohan	-4	+100
William	-7	+140
당신은 모든 구매/판매 요청 등록을 처리한 뒤 거래소 회원들의 골드/실버 변화를 계산해야 합니다.

골드 구매/판매 요청을 등록한 사람의 아이디가 순서대로 담긴 문자열 배열 req_id와 골드 구매/판매 요청의 세부 정보가 순서대로 담긴 2차원 정수 배열 req_info가 주어집니다. 모든 요청의 등록이 처리된 후 화폐 거래소 회원들의 골드와 실버 변화를 문자열 배열에 담아서 return 하도록 solution 함수를 완성해주세요.

제한사항
return 값 형식
골드 판매/구매 요청을 등록한 기록이 있는 모든 회원의 아이디, 해당 회원의 골드 변화량과 실버 변화량을 공백으로 구분하여 문자열 배열에 담습니다.
회원의 아이디가 알파벳 사전 순으로 빠른 것부터 담습니다.
골드/실버가 증가할 경우 "+", 감소할 경우 "-"를 붙여 표시합니다.
(예시) ["A +30 -200", "B -30 +200", "C 0 0"]
1 ≤ req_id의 길이 = req_info의 길이 ≤ 50,000
req_id의 i번째 원소는 i번째 요청을 등록한 회원의 아이디이며, 알파벳 대소문자로만 이루어진 길이 1~10 사이인 문자열입니다.
req_info의 i번째 원소는 i번째로 등록된 요청의 세부정보를 나타내며, [TYPE, AMOUNT, PRICE] 형태입니다.
TYPE은 요청의 종류를 나타내며, 구매 요청일 경우는 0, 판매 요청일 경우는 1 입니다.
AMOUNT는 구매/판매 할 골드의 양을 나타내며, 1~100 사이의 정수입니다.
PRICE는 구매/판매 할 골드의 가격을 나타내며, 1~100 사이의 정수입니다.
어떤 회원의 pending 상태인 구매 요청이 있다면 그 회원은 판매 요청을 등록하지 않습니다. 또한, 반대로 어떤 회원의 pending 상태인 판매 요청이 있다면 그 회원은 구매 요청을 등록하지 않습니다.
입출력 예
req_id	req_info	result
["William", "Andy", "Rohan", "Rohan", "Louis", "Andy"]	[[1, 7, 20], [0, 10, 10], [1, 10, 40], [1, 4, 25], [0, 5, 11], [0, 20, 30]]	["Andy +11 -240", "Louis 0 0", "Rohan -4 +100", "William -7 +140"]
["Morgan", "Teo", "Covy", "Covy", "Felix"]	[[0, 10, 50], [1, 35, 70], [0, 10, 30], [0, 10, 50], [1, 11, 40]]	["Covy +1 -40", "Felix -11 +440", "Morgan +10 -400", "Teo 0 0"]
입출력 예 설명
입출력 예 #1

문제 예시와 같습니다.

입출력 예 #2

4번째 요청의 등록 처리가 끝날 때까지 아무 거래도 일어나지 않으며, 화폐 거래소에 등록된 골드 구매/판매 요청은 아래 표와 같습니다.

pending 상태인 구매 요청

등록 순서	등록자 아이디	구매 수량	구매 가격
3	Covy	10	30
4	Covy	10	50
1	Morgan	10	50
pending 상태인 판매 요청

등록 순서	등록자 아이디	판매 수량	판매 가격
2	Teo	35	70
이때 "Felix"가 등록한 판매 요청인 5번째 요청의 등록은 다음과 같이 처리됩니다.

pending 상태인 구매 요청 중 구매 가격이 가장 비싼 요청은 등록순서가 4인 "Covy"의 구매 요청과 등록순서가 1인 "Morgan"의 구매 요청입니다. 두 구매 요청 중 "Morgan"의 구매 요청이 먼저 등록되었으므로 "Felix" 와 "Morgan" 사이에 수량 = 10, 가격 = 40인 거래가 이루어지며, "Morgan"의 구매 요청은 done 상태가 됩니다.
pending 상태인 구매 요청 중 그다음으로 구매 가격이 가장 비싼 요청은 등록순서가 4인 "Covy"의 구매 요청입니다. "Felix" 와 "Covy" 사이에 수량 = 1, 가격 = 40인 거래가 이루어지며, "Felix"의 판매 요청은 done 상태가 되어 처리가 종료됩니다.
위 처리가 끝난 뒤, 화폐 거래소에 등록된 pending 상태인 골드 구매/판매 요청은 아래 표와 같습니다.

pending 상태인 구매 요청

등록 순서	등록자 아이디	구매 수량	구매 가격
3	Covy	10	30
4	Covy	9	50
pending 상태인 판매 요청

등록 순서	등록자 아이디	판매 수량	판매 가격
2	Teo	35	70
또한, 화폐 거래소 회원들의 골드/실버 변화를 계산해보면 아래 표와 같습니다.

회원 아이디	골드 변화	실버 변화
Covy	+1	-40
Felix	-11	+440
Morgan	+10	-400
Teo	0	0
따라서, ["Covy +1 -40", "Felix -11 +440", "Morgan +10 -400", "Teo 0 0"]을 return 해야 합니다.